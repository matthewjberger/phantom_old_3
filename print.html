<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js dark">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Let&#x27;s Build a Game Engine in Rust</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "ayu" : "dark";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('dark')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="introduction.html">Introduction</a></li><li class="chapter-item expanded affix "><a href="final-project-preview.html">Final Project Preview</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="project-setup.html"><strong aria-hidden="true">1.1.</strong> Project Setup</a></li><li class="chapter-item expanded "><a href="creating-an-application.html"><strong aria-hidden="true">1.2.</strong> Creating an Application</a></li><li class="chapter-item expanded "><a href="the-logging-backend.html"><strong aria-hidden="true">1.3.</strong> The Logging Backend</a></li></ol></li><li class="chapter-item expanded "><a href="creating-the-rendering-library.html"><strong aria-hidden="true">2.</strong> Creating the Rendering Library</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="render-trait.html"><strong aria-hidden="true">2.1.</strong> Render Trait</a></li><li class="chapter-item expanded "><a href="vulkan-backend.html"><strong aria-hidden="true">2.2.</strong> Vulkan Backend</a></li><li class="chapter-item expanded "><a href="using-the-renderer.html"><strong aria-hidden="true">2.3.</strong> Using the Renderer</a></li><li class="chapter-item expanded "><a href="vulkan-context.html"><strong aria-hidden="true">2.4.</strong> Vulkan Context</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="vulkan-instance.html"><strong aria-hidden="true">2.4.1.</strong> Vulkan Instance</a></li><li class="chapter-item expanded "><a href="vulkan-surface.html"><strong aria-hidden="true">2.4.2.</strong> Vulkan Surface</a></li><li class="chapter-item expanded "><a href="vulkan-physical-device.html"><strong aria-hidden="true">2.4.3.</strong> Vulkan Physical Device</a></li><li class="chapter-item expanded "><a href="vulkan-logical-device.html"><strong aria-hidden="true">2.4.4.</strong> Vulkan Logical Device</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="appendix.html"><strong aria-hidden="true">3.</strong> Appendix</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="appendix-further-reading.html"><strong aria-hidden="true">3.1.</strong> A - Further Reading</a></li><li class="chapter-item expanded "><a href="appendix-keywords.html"><strong aria-hidden="true">3.2.</strong> B - Keywords</a></li><li class="chapter-item expanded "><a href="appendix-vulkan-configurator.html"><strong aria-hidden="true">3.3.</strong> C - Vulkan Configurator</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Let&#x27;s Build a Game Engine in Rust</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome! This book will guide you through the creation and design of a 3D renderer using the <a href="https://www.rust-lang.org/">Rust</a> programming language and the <a href="https://www.khronos.org/vulkan/">Vulkan</a> graphics API.</p>
<h2 id="purpose"><a class="header" href="#purpose">Purpose</a></h2>
<p>As of January 2021, the resources for learning Vulkan are scarce. The existing resources largely focus on <code>C++</code> and cover various rendering techniques. This is excellent! However, the focus for many of these resources is not on building a structured program that goes beyond the scope of tutorial code. This book is meant to be higher level, demonstrating how to build a 3D world and render it in realtime. This will be particularly of use to indie game developers looking to create a 3D game from scratch without getting overwhelmed.</p>
<h2 id="why-rust"><a class="header" href="#why-rust">Why Rust?</a></h2>
<p>Rust is a great alternative to <code>C++</code>!  A few of the benefits:</p>
<ul>
<li>It provides a smooth workflow for developers with clear, specific error messages from the compiler</li>
<li><a href="https://rustup.rs/">rustup</a> and <a href="https://github.com/rust-lang/cargo">cargo</a> make managing rust toolchain installations and rust projects straightforward</li>
<li>The lints from <a href="https://github.com/rust-lang/rust-clippy">clippy</a> help to improve the code quality and catch certain common mistakes</li>
<li><a href="https://github.com/rust-lang/rustfmt">rustfmt</a> handles formatting the code and code style</li>
<li>Memory safety. Code written outside of <code>unsafe</code> blocks is checked by the <a href="https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html?highlight=borrow#references-and-borrowing">borrow checker</a></li>
</ul>
<h2 id="target-audience"><a class="header" href="#target-audience">Target Audience</a></h2>
<p>The target audience of this book is moderately experienced developers with an interest in graphics programming. Prior graphics programming experience, particularly with <a href="https://www.opengl.org">OpenGL</a> will be particularly useful. This is the book I would have wanted to read when first starting out with Vulkan.</p>
<h2 id="what-is-covered"><a class="header" href="#what-is-covered">What Is Covered</a></h2>
<p>This book is very code-heavy and implementation focused, as opposed to other resources that may be more focused on theory.</p>
<h2 id="what-is-not-covered"><a class="header" href="#what-is-not-covered">What Is Not Covered</a></h2>
<p>This book will not go into detail on linear algebra concepts or mathematics, as there are already great resources available. This book may not go into as much depth on particular parts of the Vulkan API as other resources might. A list of useful external resources for building upon the content of this book can be found in the <code>Further Reading</code> section of the appendix.</p>
<h2 id="project-repo"><a class="header" href="#project-repo">Project Repo</a></h2>
<p>The source code for the <code>Obsidian</code> render built in this book can be found on github:</p>
<p><a href="https://github.com/matthewjberger/obsidian">https://github.com/matthewjberger/obsidian</a></p>
<p>The source code for this mdbook can also be found on github:</p>
<p><a href="https://github.com/matthewjberger/letsbuildarenderer">https://github.com/matthewjberger/letsbuildarenderer</a></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="final-project-preview"><a class="header" href="#final-project-preview">Final Project Preview</a></h1>
<h2 id="chapter-1"><a class="header" href="#chapter-1">Chapter 1</a></h2>
<ul>
<li>Set up the project structure</li>
<li>Get a window up and running</li>
<li>Create the boilerplate code used throughout the rest of the book</li>
</ul>
<p>The code in this chapter will serve as the project's foundation.</p>
<p><img src="images/chapter1.png" alt="file-structure" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="dependencies"><a class="header" href="#dependencies">Dependencies</a></h2>
<p>This project requires the <a href="https://www.rust-lang.org/">Rust programming language</a>.</p>
<p>The easiest way to get access to the Vulkan dependencies is to install <a href="https://vulkan.lunarg.com/sdk/home">the Vulkan SDK</a>. This provides access to the Vulkan Configurator, glslangvalidator, the debug layers, and other useful tools for working with Vulkan.</p>
<p>The latest version of <code>GCC</code> and <code>CMake</code> will also be required for ffi bindings to C/C++ libraries.</p>
<h2 id="development-environment-setup"><a class="header" href="#development-environment-setup">Development Environment Setup</a></h2>
<p>Using <a href="https://code.visualstudio.com/">vscode</a> and <a href="https://github.com/rust-analyzer/rust-analyzer">rust-analyzer</a> with the rust-analyzer <a href="https://marketplace.visualstudio.com/items?itemName=matklad.rust-analyzer">vscode extension</a> is recommended. However, any Rust development environment you are comfortable with will work.</p>
<p>The <a href="https://doc.rust-lang.org/book/">official Rust book</a> is a great resource if you are new to Rust.</p>
<h3 id="quick-windows-setup"><a class="header" href="#quick-windows-setup">Quick Windows Setup</a></h3>
<p>On windows, installing programs can be trickier than on other platforms. It is recommended to use a package manager such as <a href="https://scoop.sh/">Scoop</a> or <a href="https://chocolatey.org/">chocolatey</a>.</p>
<p>First, make sure <a href="https://aka.ms/wmf5download">PowerShell 5</a> (or later, include <a href="https://docs.microsoft.com/en-us/powershell/scripting/install/installing-powershell-core-on-windows?view=powershell-6">PowerShell Core</a>) and .<a href="https://www.microsoft.com/net/download">NET Framework 4.5</a> (or later) are installed. Then run:</p>
<pre><code class="language-powershell"># Install scoop
Set-ExecutionPolicy RemoteSigned -scope CurrentUser
Invoke-Expression (New-Object System.Net.WebClient).DownloadString('https://get.scoop.sh')

# Scoop uses git to update itself and 7zip to extract archives
scoop install git 7zip 

# Install the project's dependencies
scoop install gcc cmake rustup

# Set the stable rust toolchain as the default toolchain
rustup default stable

# Install vscode, kept in a separate bucket called the 'extras' bucket
scoop bucket add extras
scoop install vscode
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-setup"><a class="header" href="#project-setup">Project Setup</a></h1>
<p>The directory structure for the project will look like this:</p>
<p><img src="images/file-structure.png" alt="file-structure" /></p>
<h2 id="file-structure"><a class="header" href="#file-structure">File Structure</a></h2>
<ul>
<li><code>assets/</code>
<ul>
<li><code>hdr/</code>
Contains HDR maps used for skyboxes and environment mapping</li>
<li><code>models/</code>
Contains 3D assets, such as *.gltf and *.glb files</li>
<li><code>shaders/</code>
Contains all of the shaders used in the project</li>
</ul>
</li>
<li><code>crates/</code>
<ul>
<li><code>obsidian_app/</code>
A library that handles the window and application input boilerplate</li>
</ul>
</li>
<li><code>viewer/</code>
An application that can render 3D models, developed over the course of this book</li>
</ul>
<h2 id="creating-the-file-structure"><a class="header" href="#creating-the-file-structure">Creating the File Structure</a></h2>
<p>Create the project as a library:</p>
<pre><code class="language-bash">cargo new --lib obsidian
cd obsidian
</code></pre>
<p>Create the asset folders:</p>
<pre><code class="language-bash">mkdir assets
mkdir assets/hdr
mkdir assets/icon
mkdir assets/models
mkdir assets/shaders
</code></pre>
<p>Edit <code>Cargo.toml</code> to make the project a cargo workspace:</p>
<pre><code class="language-toml"># Leave the [package] section as is

[workspace]
members = [&quot;crates/*&quot;, &quot;viewer&quot;]
default-members = [&quot;viewer&quot;]

[dependencies]
obsidian_app = { path = &quot;crates/obsidian_app&quot; }
</code></pre>
<p>Create the application crate as a library:</p>
<pre><code class="language-bash">cargo new --lib crates/obsidian_app
</code></pre>
<p>Create and edit <code>crates/obsidian_app/src/app.rs</code> to add an <code>Application</code> struct. This will eventually contain everything needed for an <code>Obsidian</code> application, including a physics world, an entity component system, the renderer itself, and more.</p>
<pre><code class="language-rust noplaypen">pub struct Application;
</code></pre>
<p>Update <code>crates/obsidian_app/src/lib.rs</code>:</p>
<pre><code class="language-rust noplaypen">mod app;
pub use self::app::*;
</code></pre>
<p>Edit <code>src/lib.rs</code> to reference the app library:</p>
<pre><code class="language-rust noplaypen">pub mod app {
    pub use obsidian_app::*;
}
</code></pre>
<p>Create the viewer application:</p>
<pre><code class="language-bash">cargo new viewer
</code></pre>
<p>Update the <code>viewer/cargo.toml</code> to reference all of obsidian as a single library.</p>
<pre><code class="language-toml">[dependencies]
obsidian = { path = &quot;..&quot; }
</code></pre>
<p>Now, run <code>cargo run --release</code> to compile and statically link the program. You should see:</p>
<pre><code class="language-bash">&quot;Hello, world!&quot;
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-the-application"><a class="header" href="#creating-the-application">Creating the Application</a></h1>
<p>To make our application boilerplate reusable, we created the <code>obsidian_app</code> library. Now, we can start filling it out!</p>
<h2 id="configuring-the-application"><a class="header" href="#configuring-the-application">Configuring the Application</a></h2>
<p>Add an application configuration struct:</p>
<pre><code class="language-rust noplaypen">pub struct AppConfig {
    pub width: u32,
    pub height: u32,
    pub title: String,
}

impl Default for AppConfig {
    fn default() -&gt; Self {
        Self {
            width: 800,
            height: 600,
            title: &quot;Obsidian Application&quot;.to_string(),
        }
    }
}
</code></pre>
<h2 id="dependencies-1"><a class="header" href="#dependencies-1">Dependencies</a></h2>
<p>We will need to pull in crates for <a href="https://github.com/rust-windowing/winit">windowing</a>, <a href="https://github.com/dtolnay/anyhow">error handling</a>, and the <a href="https://github.com/rust-lang/log">rust logger facade</a>.</p>
<p>Add the following to <code>crates/obsidian_app/Cargo.toml</code>:</p>
<pre><code class="language-toml">anyhow = &quot;1.0.34&quot;
log = &quot;0.4.11&quot;
winit = &quot;0.24.0&quot;
</code></pre>
<p>And add the following to <code>viewer/Cargo.toml</code>:</p>
<pre><code class="language-toml">anyhow = &quot;1.0.34&quot;
log = &quot;0.4.11&quot;
</code></pre>
<h2 id="generalizing-the-application"><a class="header" href="#generalizing-the-application">Generalizing the Application</a></h2>
<p>The application can be broken down into discrete steps, such as initialization, updating, handling events, and more. This can be described with a trait:</p>
<pre><code class="language-rust noplaypen">pub trait Run {
    fn initialize(&amp;mut self, _application: &amp;mut Application) -&gt; Result&lt;()&gt; {
        Ok(())
    }

    fn update(&amp;mut self, _application: &amp;mut Application) -&gt; Result&lt;()&gt; {
        Ok(())
    }
}
</code></pre>
<p>Now we can create a function to execute any type that implements the trait:</p>
<pre><code class="language-rust noplaypen">pub fn run_application(mut runner: impl Run + 'static, configuration: AppConfig) -&gt; Result&lt;()&gt; {
    // TODO ...
}
</code></pre>
<h2 id="the-event-loop"><a class="header" href="#the-event-loop">The Event Loop</a></h2>
<p>Now we can fill out the body of the <code>run_application</code> function.</p>
<p>We can create the window, an instance of the application, and call the <code>initialize</code> function of the runner.</p>
<pre><code class="language-rust noplaypen">    let (event_loop, _window) = create_window(&amp;configuration)?;

    let mut application = Application {};

    log::info!(&quot;Running Application&quot;);
    runner.initialize(&amp;mut application)?;
</code></pre>
<p>The <code>winit</code> crate manages the event loop. For easy error handling, we will use a lambda that returns a <code>Result&lt;()&gt;</code> to handle each cycle. This lets us check for application errors and log them.</p>
<p>Inside of the event loop we can also handle events and invoke the application runner's methods.</p>
<blockquote>
<p>Note: The <a href="https://docs.rs/winit/0.24.0/winit/event_loop/enum.ControlFlow.html">control_flow</a> object allows controlling the main loop's behavior. For a game loop or realtime rendering application we will need to execute the loop continously, so we use <code>ControlFlow::Poll</code>.</p>
</blockquote>
<pre><code class="language-rust noplaypen">    event_loop.run(move |event, _, control_flow| {
        let mut cycle_result = || -&gt; Result&lt;()&gt; {
            *control_flow = ControlFlow::Poll;
            match event {
                Event::MainEventsCleared =&gt; {
                    runner.update(&amp;mut application)?;
                }
                Event::WindowEvent {
                    event: WindowEvent::CloseRequested,
                    ..
                } =&gt; {
                    *control_flow = ControlFlow::Exit;
                }
                Event::LoopDestroyed =&gt; {
                    info!(&quot;Exited application&quot;);
                }
                _ =&gt; {}
            }
            Ok(())
        };
        if let Err(error) = cycle_result() {
            error!(&quot;Application Error: {}&quot;, error);
        }
    });

</code></pre>
<h2 id="source-code"><a class="header" href="#source-code">Source Code</a></h2>
<p>The full source for the <code>app</code> module code presented so far look like this:</p>
<pre><code class="language-rust noplaypen">// crates/obsidian_app/src/app.rs
use anyhow::Result;
use log::{error, info};
use winit::{
    dpi::PhysicalSize,
    event::{Event, WindowEvent},
    event_loop::{ControlFlow, EventLoop},
    window::{Window, WindowBuilder},
};

pub struct AppConfig {
    pub width: u32,
    pub height: u32,
    pub title: String,
    pub logfile_name: String,
}

pub fn create_window(config: &amp;AppConfig) -&gt; Result&lt;(EventLoop&lt;()&gt;, Window)&gt; {
    let event_loop = EventLoop::new();

    let window = WindowBuilder::new()
        .with_title(config.title.to_string())
        .with_inner_size(PhysicalSize::new(config.width, config.height))
        .build(&amp;event_loop)?;

    Ok((event_loop, window))
}

impl Default for AppConfig {
    fn default() -&gt; Self {
        Self {
            width: 800,
            height: 600,
            title: &quot;Obsidian Application&quot;.to_string(),
            logfile_name: &quot;obsidian.log&quot;.to_string(),
        }
    }
}

pub struct Application;

pub trait Run {
    fn initialize(&amp;mut self, _application: &amp;mut Application) -&gt; Result&lt;()&gt; {
        Ok(())
    }

    fn update(&amp;mut self, _application: &amp;mut Application) -&gt; Result&lt;()&gt; {
        Ok(())
    }
}

pub fn run_application(mut runner: impl Run + 'static, configuration: AppConfig) -&gt; Result&lt;()&gt; {
    let (event_loop, _window) = create_window(&amp;configuration)?;

    let mut application = Application {};

    log::info!(&quot;Running Application&quot;);
    runner.initialize(&amp;mut application)?;

    event_loop.run(move |event, _, control_flow| {
        let mut cycle_result = || -&gt; Result&lt;()&gt; {
            *control_flow = ControlFlow::Poll;
            match event {
                Event::MainEventsCleared =&gt; {
                    runner.update(&amp;mut application)?;
                }
                Event::WindowEvent {
                    event: WindowEvent::CloseRequested,
                    ..
                } =&gt; {
                    *control_flow = ControlFlow::Exit;
                }
                Event::LoopDestroyed =&gt; {
                    info!(&quot;Exited application&quot;);
                }
                _ =&gt; {}
            }
            Ok(())
        };
        if let Err(error) = cycle_result() {
            error!(&quot;Application Error: {}&quot;, error);
        }
    });
}
</code></pre>
<h2 id="creating-the-viewer"><a class="header" href="#creating-the-viewer">Creating the Viewer</a></h2>
<p>Finally, we can use our boilerplate code to create the <code>Viewer</code>.</p>
<pre><code class="language-rust noplaypen">// obsidian/viewer/src/main.rs
use anyhow::Result;
use log::info;
use obsidian::app::{run_application, AppConfig, Application, Run};

pub struct Viewer;

impl Run for Viewer {
    fn initialize(&amp;mut self, _application: &amp;mut Application) -&gt; Result&lt;()&gt; {
        info!(&quot;Viewer initialized&quot;);
        Ok(())
    }

    fn update(&amp;mut self, _application: &amp;mut Application) -&gt; Result&lt;()&gt; {
        Ok(())
    }
}

fn main() -&gt; Result&lt;()&gt; {
    let viewer = Viewer {};
    run_application(
        viewer,
        AppConfig {
            title: &quot;Obsidian Viewer&quot;.to_string(),
            logfile_name: &quot;viewer.log&quot;.to_string(),
            ..Default::default()
        },
    )
}
</code></pre>
<p>Now, when you run the application with <code>cargo run --release</code> from the project root the application will display an empty window with a custom title!</p>
<p><img src="images/chapter1.png" alt="file-structure" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-logging-backend"><a class="header" href="#the-logging-backend">The Logging Backend</a></h1>
<p>In order for the logger facade functions to work, we will need to add a logging backend. For this project, we'll use <a href="https://github.com/drakulix/simplelog.rs">simplelog</a>.</p>
<p>Add this dependency to <code>crates/obsidian_app/Cargo.toml</code>:</p>
<pre><code class="language-toml">simplelog = { version = &quot;0.9.0&quot;, features = [&quot;termcolor&quot;] }
</code></pre>
<blockquote>
<p>Note: The <code>termcolor</code> feature allows for colored terminal log output.</p>
</blockquote>
<p>Now we can create a logger module to setup the logger backend.</p>
<pre><code class="language-rust noplaypen">// crates/obsidian_app/src/lib.rs
mod logger;
...
</code></pre>
<pre><code class="language-rust noplaypen">// crates/obsidian_app/src/logger.rs
use anyhow::{Context, Result};
use simplelog::{CombinedLogger, Config, LevelFilter, TermLogger, TerminalMode, WriteLogger};
use std::{fs::File, path::Path};

pub fn create_logger(path: impl AsRef&lt;Path&gt;) -&gt; Result&lt;()&gt; {
    let name = path.as_ref().display().to_string();
    let error_message = format!(&quot;Failed to create log file named: {}&quot;, name);
    let file = File::create(path).context(error_message)?;
    CombinedLogger::init(vec![
        TermLogger::new(LevelFilter::Info, Config::default(), TerminalMode::Mixed),
        WriteLogger::new(LevelFilter::max(), Config::default(), file),
    ])?;
    Ok(())
}
</code></pre>
<p>The <a href="https://docs.rs/simplelog/0.9.0/simplelog/struct.CombinedLogger.html">CombinedLogger</a> lets us create a <a href="https://docs.rs/simplelog/0.9.0/simplelog/struct.TermLogger.html">TermLogger</a> and a <a href="https://docs.rs/simplelog/0.9.0/simplelog/struct.WriteLogger.html">WriteLogger</a> at the same time. We will only log messages with the severity <a href="https://docs.rs/simplelog/0.9.0/simplelog/enum.Level.html#variant.Info">Info</a> and above to the terminal, and we will log all messages to the configuration file.</p>
<p>And finally we can invoke the <code>create_logger</code> function in our <code>run_application</code> method:</p>
<pre><code class="language-rust noplaypen">pub fn run_application(mut runner: impl Run + 'static, configuration: AppConfig) -&gt; Result&lt;()&gt; {
    create_logger(&amp;configuration.logfile_name)?;
    ...
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="creating-the-rendering-library"><a class="header" href="#creating-the-rendering-library">Creating the Rendering Library</a></h1>
<p>To keep the rendering code separated from the rest of the codebase, we will create a new library called <code>obsidian_render</code>.</p>
<h2 id="adding-the-render-crate"><a class="header" href="#adding-the-render-crate">Adding the Render Crate</a></h2>
<p>To start, we can create a crate for handling graphics.</p>
<pre><code class="language-bash">cargo new --lib crates/obsidian_render
</code></pre>
<p>Then we can link <code>obsidian</code> against the <code>obsidian_render</code> library, by listing it as a dependency in <code>obsidian/Cargo.toml</code></p>
<pre><code class="language-toml">[dependencies]
...
obsidian_render = { path = &quot;crates/obsidian_render&quot; }
</code></pre>
<p>and expose it as a library module.</p>
<pre><code class="language-rust noplaypen">// src/lib.rs

...

pub mod render {
    pub use obsidian_render::*;
}
</code></pre>
<h3 id="dependencies-2"><a class="header" href="#dependencies-2">Dependencies</a></h3>
<p>Add dependencies for error handling, logging, and a new dependency named <a href="https://github.com/rust-windowing/raw-window-handle">raw-window-handle</a> to <code>crates/obsidian_render/Cargo.toml</code>.</p>
<pre><code class="language-toml">anyhow = &quot;1.0.34&quot;
log = &quot;0.4.11&quot;
raw-window-handle = &quot;0.3.3&quot;
</code></pre>
<blockquote>
<p><code>raw-window-handle</code> is a library that abstracts platform specific window handles. The <code>winit</code> library uses the abstraction from this library to provide a window handle via the <code>HasRawWindowHandle</code> trait implementation on the <code>Window</code> type.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="render-trait"><a class="header" href="#render-trait">Render Trait</a></h1>
<p>To prevent coupling any one specific backend to the rest of the application, the render library can expose the renderer via a <code>Render</code> interface and consumers of the library can request a specific backend via a <code>Backend</code> enum. The <code>Render</code> interface is not intended to be a low level common abstraction over various graphics API's, but rather a high level abstraction meant to render the 3D world we will be creating later in this book.</p>
<blockquote>
<p>There is an excellent cross-platform graphics and compute abstraction library in the rust ecosystem named <a href="https://github.com/gfx-rs/gfx">gfx-rs</a>.</p>
</blockquote>
<h2 id="the-render-module"><a class="header" href="#the-render-module">The Render Module</a></h2>
<p>Create a new module named <code>render.rs</code></p>
<pre><code class="language-bash">touch crates/obsidian_render/src/render.rs
</code></pre>
<p>Update the <code>crates/obsidian_render/src/lib.rs</code> to list the new module:</p>
<pre><code class="language-rust noplaypen">pub mod render;
pub use crate::render::{Backend, Render};
</code></pre>
<p>We can list our graphics backends with an enum:</p>
<pre><code class="language-rust noplaypen">pub enum Backend {
    Vulkan,
}
</code></pre>
<p>The <code>Render</code> trait can be written as:</p>
<pre><code class="language-rust noplaypen">pub trait Render {
    fn render(
        &amp;mut self,
        dimensions: &amp;[u32; 2],
    ) -&gt; Result&lt;()&gt;;
}
</code></pre>
<blockquote>
<p>The <code>render</code> call will eventually be given a parameter containing a description of our <code>World</code> to render. The <code>World</code> implementation will come in a later chapter.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vulkan-backend"><a class="header" href="#vulkan-backend">Vulkan Backend</a></h1>
<p>Now that the <code>Render</code> trait exists, we will need to create a backend that implements it.</p>
<h2 id="render-backend-feature-flags"><a class="header" href="#render-backend-feature-flags">Render Backend Feature Flags</a></h2>
<p>To allow compiling a specific backend, we will use <a href="https://doc.rust-lang.org/cargo/reference/features.html">feature flags</a>. For the purpose of this book, we will only be implementing the <code>Vulkan</code> backend so it will be a default feature.</p>
<pre><code class="language-toml"># crates/obsidian_render/Cargo.toml
[features]
default = [&quot;vulkan&quot;]
vulkan = [] 
</code></pre>
<h2 id="vulkan-render-backend"><a class="header" href="#vulkan-render-backend">Vulkan Render Backend</a></h2>
<h3 id="setting-up-the-backend"><a class="header" href="#setting-up-the-backend">Setting Up the Backend</a></h3>
<p>Create a new module named <code>vulkan.rs</code> and a folder for its modules:</p>
<pre><code class="language-bash">touch crates/obsidian_render/src/vulkan.rs
mkdir crates/obsidian_render/src/vulkan
</code></pre>
<p>Update the <code>crates/obsidian_render/src/lib.rs</code> to list the new module:</p>
<pre><code class="language-rust noplaypen">#[cfg(feature = &quot;vulkan&quot;)]
mod vulkan;
</code></pre>
<h3 id="creating-the-vulkan-render-module"><a class="header" href="#creating-the-vulkan-render-module">Creating the Vulkan Render Module</a></h3>
<p>Create a file for the Vulkan specific render module:</p>
<pre><code class="language-bash">touch crates/obsidian_render/src/vulkan/render.rs
</code></pre>
<p>Declare it as a module, and expose the <code>VulkanRenderBackend</code> to the crate:</p>
<pre><code class="language-rust noplaypen">pub(crate) use self::render::VulkanRenderBackend;

mod render;
</code></pre>
<p>Declare the <code>VulkanRenderBackend</code> as a plain struct that implements the <code>Render</code> trait:</p>
<pre><code class="language-rust noplaypen">// crates/obsidian_render/src/vulkan/render.rs
use crate::Render;
use anyhow::Result;
use raw_window_handle::HasRawWindowHandle;
use log::info;

pub(crate) struct VulkanRenderBackend;

impl Render for VulkanRenderBackend {
    fn render(
        &amp;mut self,
        _dimensions: &amp;[u32; 2],
    ) -&gt; Result&lt;()&gt; {
        Ok(())
    }
}

impl VulkanRenderBackend {
    pub fn new(
        _window_handle: &amp;impl HasRawWindowHandle,
        _dimensions: &amp;[u32; 2],
    ) -&gt; Result&lt;Self&gt; {
        info!(&quot;Created Vulkan render backend&quot;);
        Ok(Self{})
    }
} 
</code></pre>
<h2 id="instantiating-graphics-backends"><a class="header" href="#instantiating-graphics-backends">Instantiating Graphics Backends</a></h2>
<p>We can now write an associated method for the <code>Render</code> trait to provide a <a href="https://doc.rust-lang.org/book/ch17-02-trait-objects.html">trait object</a> (some type implementing the <code>Render</code> trait) by specifying the desired backend.</p>
<pre><code class="language-rust noplaypen">// creates/obsidian_render/src/render.rs
#[cfg(feature = &quot;vulkan&quot;)]
use crate::vulkan::VulkanRenderBackend;

impl dyn Render {
    pub fn create_backend(
        backend: &amp;Backend,
        window_handle: &amp;impl HasRawWindowHandle,
        dimensions: &amp;[u32; 2],
    ) -&gt; Result&lt;impl Render&gt; {
        match backend {
            Backend::Vulkan =&gt; VulkanRenderBackend::new(window_handle, dimensions),
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="using-the-renderer"><a class="header" href="#using-the-renderer">Using the Renderer</a></h1>
<p>Now we can instantiate a renderer in our <code>obsidian_app</code> library, before moving on to filling out the Vulkan graphics backend.</p>
<p>List the <code>obsidian_render</code> library as a dependency in <code>crates/obsidian_app/Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
...
obsidian_render = { path = &quot;../obsidian_render&quot; }
</code></pre>
<p>Now we can instantiate the renderer by modifying <code>crates/obsidian_app/src/app.rs</code>.</p>
<p>Import the library types:</p>
<pre><code class="language-rust noplaypen">use obsidian_render::{Render, Backend};
</code></pre>
<p>Add a <code>renderer</code> property to the <code>Application</code> struct as a boxed trait object, and instantiate it in a constructor:</p>
<pre><code class="language-rust noplaypen">pub struct Application {
    pub renderer: Box&lt;dyn Render&gt;,
}

impl Application {
    pub fn new(window: &amp;Window) -&gt; Result&lt;Self&gt; {
        let logical_size = window.inner_size();
        let window_dimensions = [logical_size.width, logical_size.height];
        let renderer = Box::new(Render::create_backend(
            &amp;Backend::Vulkan,
            window,
            &amp;window_dimensions,
        )?);
        Ok(Self { renderer })
    }
}
</code></pre>
<p>The <code>Application</code> can now be created with the constructor in the <code>run_application</code> method:</p>
<pre><code class="language-rust noplaypen">// '_window' becomes 'window' here since it is now used
let (event_loop, window) = create_window(&amp;configuration)?;

let mut application = Application::new(&amp;window)?;
</code></pre>
<p>If you run the program now with <code>cargo run --release</code>, the log output should include a message saying that the Vulkan render backend was created.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vulkan-context"><a class="header" href="#vulkan-context">Vulkan Context</a></h1>
<p>Now we can start using Vulkan! This section will detail a self contained structure for setting up and store the fundamental objects required to run a Vulkan application.</p>
<blockquote>
<p>From this point on in the book, the instructions for setting up and creating the files will not detail each line and step, and will rely on the accompanying source code for reference. All important sections of code will be explained, however!</p>
</blockquote>
<p>The structure will be called a Vulkan <code>Context</code>. This is not an official Vulkan term, but rather the name for our grouping of Vulkan objects.</p>
<pre><code class="language-rust noplaypen">pub struct Context {
    pub allocator: Arc&lt;vk_mem::Allocator&gt;,
    pub device: Arc&lt;Device&gt;,
    pub physical_device: PhysicalDevice,
    pub surface: Option&lt;Surface&gt;,
    pub instance: Instance,
    pub entry: ash::Entry,
}
</code></pre>
<p>The order the struct fields are declared in determines the order that they are <code>Drop</code>ped in. This will become important later, as cleaning up Vulkan resources has to happen in a particular order. Resources must not be in use when they are destructed, so declaring the struct this way enforces the correct order.</p>
<p>In reverse order, the fields are as follows.</p>
<ul>
<li>
<p><code>entry</code></p>
<p>The function loader from the <code>ash</code> library.</p>
</li>
<li>
<p><code>instance</code></p>
<p>A wrapper around a <a href="https://docs.rs/ash/0.31.0/ash/vk/struct.Instance.html"><code>vk::Instance</code></a>, which stores application state because there is no global state in Vulkan.</p>
</li>
<li>
<p><code>surface</code></p>
<p>A wrapper around a <a href="https://docs.rs/ash/0.31.0/ash/extensions/khr/struct.Surface.html"><code>ash::extension::khr::Surface</code></a>. A surface is required when rendering to a window.</p>
</li>
<li>
<p><code>physical_device</code></p>
<p>A wrapper around a <a href="https://docs.rs/ash/0.31.0/ash/vk/struct.PhysicalDevice.html"><code>vk::PhysicalDevice</code></a>. On simple systems, this a physical device represents a specific, physical GPU.</p>
</li>
<li>
<p><code>device</code></p>
<p>A wrapper around a <a href="https://docs.rs/ash/0.31.0/ash/vk/struct.Device.html"><code>vk::Device</code></a>. A logical device represents the application's view of the physical device. Vulkan calls will be made primarily on this object.</p>
</li>
<li>
<p><code>allocator</code></p>
<p>Vulkan requires the application to handle allocating memory on its own. Thankfully, AMD has released a library that does this task well, called the <a href="https://github.com/GPUOpen-LibrariesAndSDKs/VulkanMemoryAllocator">Vulkan Memory Allocator</a>. The rust bindings are provided by <a href="https://github.com/gwihlidal/vk-mem-rs">vk-mem-rs</a>. Using a type from the <code>vk-mem-rs</code> library, we can create and store a memory allocator.</p>
</li>
</ul>
<h2 id="vulkan-handles"><a class="header" href="#vulkan-handles">Vulkan Handles</a></h2>
<p>Vulkan objects are constructed via API calls, and return handles. The wrappers we will create instantiate particular Vulkan objects, store their handles, and implement the <code>Drop</code> trait to call a <code>destroy_instance</code> API call which frees the resource. This intentionally ties the lifetime of the Vulkan object to lifetime of the Rust wrapper type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vulkan-instance"><a class="header" href="#vulkan-instance">Vulkan Instance</a></h1>
<p>The first wrapper needed to create our Vulkan context will be the <code>Instance</code>. This is a wrapper around the <code>ash::Instance</code> type.</p>
<pre><code class="language-rust noplaypen">pub struct Instance {
    pub handle: ash::Instance,
}
</code></pre>
<p>The constructor on this wrapper is as follows.</p>
<pre><code class="language-rust noplaypen">pub fn new(entry: &amp;ash::Entry, extensions: &amp;[*const i8], layers: &amp;[*const i8]) -&gt; Result&lt;Self&gt; {
    let application_create_info = Self::application_create_info()?;
    Self::check_layers_supported(entry, &amp;layers)?;

    let instance_create_info = vk::InstanceCreateInfo::builder()
        .application_info(&amp;application_create_info)
        .enabled_extension_names(extensions)
        .enabled_layer_names(layers);

    let handle = unsafe { entry.create_instance(&amp;instance_create_info, None) }?;
    Ok(Self { handle })
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vulkan-surface"><a class="header" href="#vulkan-surface">Vulkan Surface</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vulkan-physical-device"><a class="header" href="#vulkan-physical-device">Vulkan Physical Device</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vulkan-logical-device"><a class="header" href="#vulkan-logical-device">Vulkan Logical Device</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="appendix"><a class="header" href="#appendix">Appendix</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="a---further-reading"><a class="header" href="#a---further-reading">A - Further Reading</a></h1>
<ul>
<li>
<p><a href="https://vulkan-tutorial.com/">The Vulkan Tutorial by Alexander Overvoorde</a></p>
<p>This is where most people learn Vulkan. It goes over all the fundamentals of Vulkan and focuses on explaining the API and using it to make a graphics application.</p>
</li>
<li>
<p><a href="https://github.com/adrien-ben/vulkan-tutorial-rs">A Rust Version of the Vulkan Tutorial</a></p>
<p>This is an excellent Rust port of the C++ Vulkan Tutorial.</p>
</li>
<li>
<p><a href="https://github.com/SaschaWillems/Vulkan">Sascha Willems Vulkan Tutorials</a></p>
<p>Sascha Willems has a github repo full of a variety of examples of how to use the Vulkan API to achieve various graphics programming techniques. This is highly recommended for anyone using the Vulkan API.</p>
</li>
<li>
<p><a href="https://learnopengl.com/">Learn OpenGL</a></p>
<p>This is a website about graphics programming that focuses on OpenGL programming, but the techniques are all applicable to Vulkan.</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="b---keywords"><a class="header" href="#b---keywords">B - Keywords</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="c---vulkan-configurator"><a class="header" href="#c---vulkan-configurator">C - Vulkan Configurator</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
